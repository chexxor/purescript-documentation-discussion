
## Source: Why is Elm more Popular than Purescript?

https://www.reddit.com/r/haskell/comments/79i7h9/why_is_elm_more_popular_than_purescript/

### Opening Thread

> I thought that PS offered most of the expressive power that Haskell has, without the language extensions.
> Isn’t it a myth that PureScript is front end only? If your ultimate goal is to learn Haskell that you would use seriously, I suspect that preparing yourself with Elm first would be a waste of time. What do you guys think.
> EDIT: Not that the purpose of Elm is to eventually move on to Haskell, but I can picture some people 'settling' for Elm if they think PureScript or HS are too hard to start with.

### Thread

> I think Elm focusses on learning and the ease of getting started. It's not to say PureScript doesn't focus on those things, but it's not our number one concern. We've been focusing on building the language instead. Our learning curve is much steeper for beginners because we assume familiarity (or willingness to learn) more concepts up front.

- core contributors to PS prioritize improving the language over improving the documentation / onboarding process

> If you're learning FP for the first time, I think it makes sense to start with Elm. Eventually, you might find you want more type system features, so you might move to PureScript - or maybe not, and that's fine too.

- Elm is a good starting FP language that might be powerful enough for many use cases. For others, they might use it as a stepping stone to get to PureScript after wanting more. Each has it's place.

> Also, we're not optimizing for adoption numbers. You might say we have a more of an "avoid (success at all costs)" mentality in that sense.

- The phrase "avoid success at all costs" could be interpreted in two different ways. First way, "(avoid success) at all costs," is attempting to avoid any sort of success no matter what. It would imply trying to stop people from using the language at all. This is not how the above phrase is meant. Second way, "avoid (success at all costs)," does not prioritize "success" (that comes at the cost of poor decisions with negative long-term consequences) over decisions based on solid foundations. Success is desired, but people will not take shortcuts to get there. PS has the mentality of the second one, which sometimes is at odds with others' desires to see it "succeed" even if that means the language would suffer over the long-term.

> I know that PureScript is never going to have a massive number of users. That's even a good thing in my opinion. It sits in a narrow niche, and you need to value a lot of the same things as the developers to start to see real value from it. But the users who do use it regularly tend to really like using it, and produce some amazing things with it.

- PS is not meant for everyone, nor does it try to be. Rather, it tries to be great at specific things, so that those who value the same things the core contributors value are drawn to it and use it.

<hr>

> I think Elm and PureScript both benefit from the "culture" generated by Haskell. We know what data structures work, that do notation works, that type classes work and which ones are definitely useful (functors, Monoid, etc.), parsers, ST, etc....
> That also makes it really easy for us to switch between these languages. I barely had to learn anything for either PureScript or Elm to be productive. That's a real opportunity for trying out alternatives.

- Once the core ideas behind FP languages are learned, one can switch between them relatively easily.

<hr>

> If your goal is to learn Haskell, then just learn Haskell.
> If you want a practical language for client-side web programming (that is also a full-fledged backend language thanks to node.js), that is similar to Haskell, then PureScript
> If you want a pure functional language for client-side web dev that is easy to learn, go with Elm.

<hr>

> I think a lot of devs aren't necessarily looking for expressive power in a language. They're looking for a way to stop making nightmare code bases. I think there's an impression that Elm has just enough complexity to get the job done on the front end, while still providing many of the benefits of strict typing, even if its not as elegant as its possible to be in a more full featured language.
> Also, doesn't elm have better performance than purescript?

<hr>

> Elm is easy to move into. It doesn't ask you to learn anything but syntax. You just don't realize that the abstraction ceiling is so low until a month later when you start hitting your head.
> It also has the first-mover advantage. It was on the scene a long time before purescript got started.
> Elm drags Javascript 20% of the way towards Haskell. Purescript drags Haskell 20% of the way towards Javascript.
> There are a lot more Javascript developers than Haskell developers and each has been pushed pretty heavily at those target audiences respectively.

<hr>

> This is written as gospel but it isn't. We're happily using Elm at CircuitHub with 50k lines of code and are yet to hit this ceiling. I understand Ed writes code differently than I do, but consider that maybe he writes code differently to you too. For some applications, they are just big because they are, well, big. Abstracting to the nth degree isn't going to shift the complexity away from a large feature set. In this space, I actually appreciate Elm's limited means of abstraction in return for the consistency I get. I just get my head down, write the code in the same boring pattern, and get the job done. I wouldn't want this approach in Haskell, but... tool for the job and all that.

- 50k app and the "abstraction ceiling" has not been hit yet. App does require a lot of boilerplate-y code, but it works and solves the business problem at the end of the day

< hr>

> ... I just don't see a viable path to learning PureScript at all that doesn't start with "first, learn Haskell." There are not enough resources to walk people through the baby steps in PureScript itself; and as far as I can tell, the community is not at all interested in compromising their abstraction towers with any kind of simplified ideas at all!

- Not many PS learning resources have been available in times past
- Some perceive the core contributor's focus on developing the language over writing good documentation as a sort of "We're really smart. We won't come down to you; you'll have to come to us" mindset.

<hr>

> I learned PureScript before Haskell (and my Haskell usage is limited to some scotty/haxl/generics-sop usage), and it really came down to using libraries I knew I wanted to use (Aff, Halogen, etc.), reading docs and asking questions when I was stuck, and slowly learning the basics after I had already been writing programs I wanted to write.
> There are also many more concretely-typed aliases all over the place to help you use the libraries, so I don't anyone is uninterested in compromising abstraction for easier use.

- Learner wrote working programs based on a few libraries and patterns/examples by the looks of it before learner really understood things.

<hr>

>> I just don't see a viable path to learning PureScript at all that doesn't start with "first, learn Haskell."
>
> The PureScript by Example book doesn't require any previous Haskell knowledge and goes at a reasonable pace for the first six chapters or so.

- Seems that PureScript by Example was not well-known by those outside the PS community?

>> and as far as I can tell, the community is not at all interested in compromising their abstraction towers with any kind of simplified ideas at all!
>
> Not true - every aspect of PureScript is swappable, and there exist alternative standard libraries for beginners. See [Neon](https://github.com/tfausak/purescript-neon) for example. Our "standard" standard library just represents one set of opinions, but it's very possible to build your own ideal set of abstractions, and I know this because I've done it.

- First I've heard of Neon. It's also only updated for `0.11.7`, so this comment is somewhat out of date, too. Still, the ideas explained in Neon would make learning FP code easier. I just wonder what the tradeoffs would be.

### Thread

> According to "Let's be mainstream! User focused design in Elm", Elm targets JavaScript programmers, optimizes its landing page's feature list to make its advantages clear to JavaScript programmers, and optimizes the wording of its documentation to eliminate scary words like "Monad". Simplicity and learnability are high-priority goals for Elm.
>
>>  Why is Elm more popular than PureScript?
>
> In my opinion, popularity is obtained by making the advantages as clear as possible and making the switching costs as low as possible. Elm is doing a great job on both, as outlined in the above video.

- Elm is more popular because, unlike PS, one of its main purposes is to draw JS developers towards it. It does this by showing clear and specific examples where Elm provides better solutions than JS does and by helping people migrate to the language/ecosystem.

> Haskell is doing a terrible job at both. Learning Haskell is much harder than learning yet another imperative language, and while I think that the clarity, correctness, and debugability which results is worthwhile, it's hard to succinctly explain how giving up on side effects magically leads to those benefits.
> I am not super familiar with PureScript, but my impression is that it is trying to be a better Haskell than Haskell. It has an even more finely-detailed numeric hierarchy, for example, and its lenses are based on Profunctors instead of functions. Both of those sound like improvements to me, but to someone whose numeric hierarchy only has float, int and BigInt, that's probably just going to be an even steeper learning curve.

- PS "tries to be a better Haskell than Haskell" but comes at the cost of needing to learn many more concepts. Not everyone needs that power, nor wants to gain those benefits when other competing interests call (i.e. learning another imperative programming language might have better overall gain).

>> preparing yourself with Elm first [...]
>
> I don't think either Elm nor PureScript is designed to be a stepping stone towards Haskell, and I don't think most people who learn either language are using them as such. My impression is that most Elm learners come from JavaScript, while PureScript learners come from Haskell.

-

>> [...] would be a waste of time
>
> On the contrary, I do recommend learning Elm before Haskell. Like I said, Elm is designed to be easy to learn, so the learning curve will be a lot softer than Haskell's, and its teachings about purity, immutability and types carry over to Haskell. So even though Elm isn't designed to be a stepping stone towards Haskell, I think using it as such is a great idea.

<hr>

>> my impression is that it is trying to be a better Haskell than Haskell.
>
> That's definitely not an explicit goal, but we did tidy things up along the way that we thought were worthwhile - Semigroup/Monoid, Applicative/Monad, Foldable/Traversable, Num vs Field, and so on.

- PS seems to be trying to remove the baggage that Haskell continues to carry, but it is not explicitly trying to replace/improve it.

> I started PureScript because the language I wanted on the front end didn't exist, and that's still why I work on it and use it. I want type classes, and functional dependencies, and higher kinded types, and rank N types, and various other things in my type system. And I want predictable code generation, and a minimal language and standard library. That combination just didn't exist when I started on PureScript.

- FP programmer wanted a better solution for web dev and implemented such a solution.

### Comment

> As a kind of typical case of JavaScript/Ruby/Java dev, I tried out Elm first because it was marketed quite loudly and it was the only option I knew of at the time (2015) other than F#, which I wasn't about to use for various reasons.

- Elm had first-mover advantage.

> I only found PureScript later when I was disappointed with Elm and I saw some stuff from Bodil on Twitter about PureScript.
> That's about it. Nobody in my circles told me there was even an option.
> Even today, if you talk to a JavaScript user who's "in the know" about things, they really only know about Elm and ReasonML thanks to the marketing efforts. PureScript, Fable, and GHCJS don't exist in their Twitter feeds.

- PS and other FP solutions that are more powerful than Elm are not on most JS developer's radar of possible alternatives.

### Thread

> I’ve used both and had an easier time with Elm than with PureScript, although I don’t think I necessarily “enjoyed” either one more than I would have just enjoyed pure JavaScript.
> For one, Elm has some really nice error messages. Second, there’s the whole “publish action -> update store -> notify subscribers” framework that tends to be a bit easier in terms of barriers to entry.

- Elm has nice errors
- Elm's architecture is simple and understandable

> It also feels like PureScript is unmaintained. I tried PS out twice over a year or two and the docs were more or less the same (very sparse). The package manager as of like 6 months ago still used Bower, which has been phased out pretty much everywhere (even Bower devs say to stop using Bower).

- PS was perceived as "unmaintained" because the docs hadn't been improved

> A big issue for me, too, was that I felt like I was looking at Haskell docs to figure out how to do things more than I was using PS documentation. At that point, why not just use a Haskell compiler that targets JavaScript instead?

- New learner looked at Haskell's docs rather than PS' docs to understand something.
- It's not clear to new learner why one shouldn't just use GCHJS or some similar Haskell solution.

> And, if I end up using the FFI to include the majority of my JS code, can’t I just write functional JavaScript code in the first place and cut out the middle man?

- If much of person's code uses FFI, then is the overall advantages that PS bring better than just writing vanilla JS?
- Counter argument: the above issue might be due to useful libraries not existing in PS that then leads the person to need to use FFI to get the same thing.

> Even without the runtime requirement that Elm has, PureScript introduces a lot of framework and dependency cruft, which is in some ways worse (manually currying and wrapping functions to defer evaluation — the generated code is readable but uglier than, say, using Ramda).

- Another point about vanilla JS + libraries being better than PS for various reasons.

<hr>

>> It also feels like PureScript is unmaintained.
>> The package manager as of like 6 months ago still used Bower
>
> PureScript is very much maintained. We should have a new major release coming out shortly. The Bower thing is unfortunate, because JS developers don't use it, but it's still perfect for our needs. It's actually a very good piece of software, if you look at it as a semver layer on top of Git and not a JS package manager.

- Bower should be seen as a "semver layer on top of Git" and less of a JS package manager.

>> ... why not just use a Haskell compiler that targets JavaScript instead?
>
> Yes, GHCJS exists and it is excellent, but it makes some very different design decisions, so it doesn't really make sense to say that you would switch from PS to GHCJS for that reason. You wouldn't choose PureScript because you wanted Haskell-to-JS, because it's not that.

- Switching to GHCJS isn't the same idea as a "Haskell-to-JS" compiler

<hr>

>> What specific design differences exist between PS and GHCJS? Why would someone choose one or the other?
>
> GHCJS is full Haskell compiled to JavaScript, including something like the GHC runtime running in JavaScript. PureScript is a separate language from Haskell (in particular, it is strict), and is very minimal by comparison. It has no runtime, and no required standard libraries. You can use it a bit like TypeScript, as a completely standalone thing, generating very small, self-contained libraries.

- GHCJS indlues the entire Haskell compiler in JS (probably slows down a site's load time significantly) and is designed for whole-system apps
- PS has no runtime requirement and can be used like a pocket knife: a solution to a whole-system app, a simple library, a small part of some current system that integrates well, etc.

### Thread

> I think that an ideal progression from Elm to Purescript would be:
> 1. Introduction to plain Elm. (I think various people in this thread really underestimate how different Elm is from Javascript.)
> 2. Introduction to problems that have enough size and complexity that people begin to itch for the features that Elm doesn't have (polymorphism, especially).
> 3. An introduction to Purescript tailored to the graduating Elm programmer. Something focused on how Purescript adds to Elm. [This is missing.]
> 4. A documentation aesthetic that caters (not exclusively) to the person who wants to learn the concrete before the abstract.

- Elm is stil quite different from Javascript
- Once people love Elm, it's lack of features can make others want something better with PS as the proposed "obvious solution."
- OO programmers likely need a bottom-up approach to teaching FP rather than the top-down approach many use

> I seem to remember that the early Java documentation just assumed that anyone reading the API for a class would naturally know everything about all the superclasses. That turns out not to be a great idea, but a lot of static FP documentation does the equivalent. (A pet peeve of mine: to really understand the Haskell lens library's `At` -- something I suspect people will want to use soon after being exposed to lenses -- you must first understand `Index` and even `Traverse`. I don't understand the appeal of such an approach.)

- Documentation should focus first on helping people solve real problems with practical bottom-up documentation. The theoretical top-down stuff can come later on once they realize the value of the abstraction.

<hr>

>> I see you are writing a book along those lines, so I may as well put in the link: https://leanpub.com/outsidefp
>
> Thanks. I hope this approach is viable without forcing people to buy a book-length treatment. (Though I think they should!)

- The above 4-step approach to helping people transition to PS seems to be the rough outline of the "Outsider's Guide to FP" book

### Comment

> PureScript compiles to JavaScript, which is the "native" front-end platform. While it's possible to run PureScript generated JavaScript outside a web browser using Node, it probably makes sense from a performance perspective to limit the number of virtualisation layers. In that regard, PureScript is most useful on the front-end.

- While PS can be used on the back-end, it's likely not as performant than other solutions because of the virtualization layers. Thus, it's likely only for the front-end

### Thread

>> "Rigid/skolem type variable bound by x has escaped"
>
> In all seriousness, I think it's because Elm has focused on bringing web devs to FP, not bringing FP devs to the web. Both have different niches and priorities. Elm puts a ton of effort into error messages and keeping the language minimal. As a result, it's not as generic and requires more boilerplate, but it's an easier sell to non experts.

- Person believes that Elm is more popular because it's errors are better than PS' errors. It's easier to sell to your average no-experties-in-FP developer

<hr>

> Our error messages have gotten quite a lot better since then. In that case, you would see something like:
```

  The type variable h, bound at

    File.purs, line 9, column 14 - line 9, column 25

  has escaped its scope, appearing in the type

    Eff t1 (STRef h0 Int)

in the expression runST (newSTRef 1)
in value declaration test
```

> which I think is pretty decent, given what's actually going on in this case. As you add more type system features, of course it will be harder to understand the ways in which it can fail. It's one of the reasons why Elm is better for newcomers to FP. I would love to see a language with Elm's error messages and PureScript's type system features, I just don't know if it's possible.

- The PS' language's errors have gotten better and there's only so much an error can say before it's actually teaching a concept rather than giving an error message.
- It might be impossible to have PS' powerful type system and all its features with error messages that are as helpful/clear as Elm's error messages.

<hr>

> My take on the above [On the Ergonomics of FP Compiler Errors in Purescript/Haskell](http://metaleap.net/blog.ergonomic-purescript-error-messages.html#My%20take)
> As I churn out more code and run into more compiler messages, I'll submit alternative formulation ideas to the repo over time =)

### Thread

> We tried using Elm across a team of rather experienced Haskell developers for frontend work.
> Over the course of about 6 months, we ran into a situation where the lack of rank-n types combined with the lack of typeclasses meant that a rather large chunk of code turned into a repetitive cut-and-paste fest with simply no work-around possible in the language-as-offered. If we'd had either one we could have worked around the situation. (We spent a couple of months in more-or-less untyped hell trying to hack around it in various ways.)

- Haskellers who know of better abstractions were restricted by Elm's lack of features. Moreover, Elm did not allow their hacks to work, or at least not work long.

> This experience left me rather soured on the idea of trying to employ Elm in earnest.
> YMMV, but mind you the application itself largely centered around using a number of interpretations of an EDSL that didn't lend itself to first order presentation, so this was literally our entire use-case for the language.
> We ultimately moved to PureScript and it served us well for years without ever once running into the same sort of situation. We rewrote the entire application in PureScript more or less overnight. With the subset of Haskell type system features offered there was always some work-around to the various limitations on hand.

- Haskellers who alraedy knew of better abstractions did not have trouble migrating to PS and experience the benefit quickly.

> This is compounded by the fact that this sort of issue raised from the Haskell-side of the community largely falls on deaf ears in Elm, while on the Purescript front any similar impediment is rather rapidly patched and updated if there is any path forward. `/u/paf31` a very competent maintainer and I'm much more comfortable with the type theory that underlies Purescript than that of Elm.
> When Purescript came along and offered up typeclasses, the major reaction on the Elm side was a sigh of relief over the fact that the Haskell folks finally shut up and went away.

- Elm was needlessly bombarded by Haskellers who wanted a more powerful Elm, which conflicted with Elm's design goals/philosophy. PS, which did have those goals, met these needs/desires well.

> Stuck comparing the two languages, I'm left with a ridiculously lopsided sense of advantages on one hand, and a rather deep well of frustration on the other. This somewhat colors my phrasing.

>> Where I work we're at 200,000 lines of Elm in production, deployed for 2 years, students answering millions of questions on it daily, and we've still had zero production runtime exceptions ever.
>
> Mind you, touting the fact that you have 200,000 lines of Elm in production doesn't really help sell me on it. ;) If we had gone that route, our 25,000 lines of Purescript may have easily wound up as 200,000 lines of Elm. Then again, I maintain something like 2 million lines of Haskell, so I'm sure there is somebody out there snarking the same thing at me. =)

- Stating an app's complexity in lines of code is not necessarily a good measurement because higher abstractions can reduce that number.

<hr>

> I think it would be as much of a mistake for Elm to add typeclasses as it would be for PureScript to remove them. The languages have different design philosophies, and I think it benefits all of us to have an attitude of "PureScript does it this way and Elm does it that way, and if you are looking for characteristics A, B, and C you'll probably prefer the way language X does things."
> The way I see it, we have a constellation of compile-to-JS functional programming languages with different design philosophies. Programmers have different preferences, and projects have different needs. We're all better off if we can easily gravitate towards tools that are the best fit for our situations.

- Comparing Elm and PureScript is like comparing apples and oranges. Just realize that each language is a tool that better suits some people's use cases and preferences than others and leave it at that. People should know what the design decisions are and their tradeoffs and be able to make an informed decision.

> I expect most Haskellers will like PureScript better than Elm, and so I'm happy to recommend PureScript over Elm as a better default choice for anyone who is already happily using Haskell!

- Haskellers should not use Elm because they will find it too limiting. Rather, they should use PS.

### Thread

> One thing that stops me from learning PureScript is [the rendering performance of existing libraries, not the language itself] ([source](https://www.reddit.com/r/haskell/comments/79i7h9/why_is_elm_more_popular_than_purescript/)). Elm probably has the fastest virtual DOM implementation out there and I've seen some Halogen/Thermite benchmarks showing that the performance is much worse than even in JS frameworks. Not sure how accurate they are though.

- One valid reason for not wanting to learn PS: rendering speeds of Halogen/Thermite frameworks weren't fast enough for person's use case.

### Comment

> my 5 cents: you can find learning material for elm which do not assume knowledge of JS/web, in purescript you cannot. So if you know haskell, but not JS, you would probably go with elm

- Potential learning audience: those who have no experience in web development whatsoever

### Comment

> Personally, I started with elm because I wanted to make something on the frontend, didn't want javascript and wanted a good type system.
>
> I think that elm being simpler helped me get over the inital hurdle when learning my first functional language and the experience with elm is helping me learn haskell now, even though that wasn't my initial intention

- Another learner stating that the JS -> Elm learning path worked well for learning FP concepts. It's not clear whether the learner also learned PS.

### Comment

> Elm is simpler and easier.
> If one wants to build a todo application, One even without any functional programming language can create the app in an hour with elm.
> With Purescript, well there is no way before knowing how to handle side effects.

- Elm has a faster onboarding process where one feels productive. PS, due to its powerful type system, will never be able to have a faster onboarding process.

> It turns out people love simpler language especially coming from js background.

- Person believes that JS-background people love simpler languages with smaller learner curves. I'm not sure how true that is considering how many features exist in the JS language (unless one adheres to the principles in "Javascript: The Good Parts").

> As a haskeller, you will hate both or at least not like it as much as Haskell because after all it is not haskell.
> Both languages make you feel like it is a web dev version of Haskell, but it is going to fail you at some point with some features missing.

- Haskellers will likely be unsatisfied wither either language at some point because neither of them are Haskell.
