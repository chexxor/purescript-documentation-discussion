# All Interpretations

The following interpretations have been copied over from various sources. The bracketed content `[example_slug_name]` refers to the unqiue slug name of a source, so that one could see the full context of that interpretation.

<hr>

- There are lots of easy documentation problems to resolve in the core documentation. [Features_You_Want_Future_PureScript_to_Not_Have]
- A PureScript user prefers PureScript over Elm because they don't like a language which dogmatically enforces a certain way of programming. [Hitchhikers_Guide_to_Elm]
- A PureScript user believes PureScript's FFI is simpler than Elm. [Hitchhikers_Guide_to_Elm]
- A PureScript user believes PureScript compiles to smaller amounts of JS than Elm for the same thing, making pages load faster than Elm-written ones. [Hitchhikers_Guide_to_Elm]
- A PureScript user entered PureScript after going through Elm. [Hitchhikers_Guide_to_Elm]
- A PureScript user feels limited by Elm's type system. [Hitchhikers_Guide_to_Elm]
- A PureScript user believes that a language can limit what you can do and learn, and is reason for leaving the language. [Hitchhikers_Guide_to_Elm]
- A PureScript user believes that learning PureScript is hard to learn, and the reason is it is powerful. [Hitchhikers_Guide_to_Elm]
- A PureScript user believes that using it is dead-simple because it compiles to JavaScript (because it is readable?). [Hitchhikers_Guide_to_Elm]
- A PureScript user has trouble figuring out how to solve application problems in PureScript, which is a reason for why PureScript is hard to learn. [Hitchhikers_Guide_to_Elm]
- A PureScript user feels rewarded when using PureScript because the primary sticking points are figuring out how to do things *in* the language, rather than figuring out *non-language* problems. [Hitchhikers_Guide_to_Elm]
- A PureScript user believes that PureScript is good for solid development of frontend applications. [Hitchhikers_Guide_to_Elm]
- A non-PureScript user prefers a simple language with a gradual/short learning curve and is willing to compromise on the quantity of manually-written code to have it. [Hitchhikers_Guide_to_Elm]
- A JavaScript/React/PureScript user believes PureScript's FFI is fairly easy and is better than ReasonML's and Elm's FFI. [Hitchhikers_Guide_to_Elm]
- People who hear that Purescript "compiles to Javascript" incorrectly assume/expect it to use a syntax similar to Javascript or other compile-to-JS languages. [Elm_PureScript_In_Depth_Overview]
- Author's first major issue and turn off was not being able to read the syntax of a Haskell-like language. This issue alone made him choose to look at Elm rather than PureScript, which is arguably more powerful than Elm. Unlike most people, the author did not give up and looked at Haskell/PureScript again, eventually reaching an understanding via each language's "standard" for learning them. [Elm_PureScript_In_Depth_Overview]
- The simple demo, `star-dodge-clone`, still assumes too much advanced background info for a new learner to understand it. People think 'simple' demos (like that above) don't require that much understanding. The "simple" demo above uses the following language features: [Elm_PureScript_In_Depth_Overview]
    - the `Eff` monad
    - a Graphics library
    - symbolic functions (e.g. `<$>` instead of `map`)
    - implicit monadic functions via the `<-` bind syntax
    - Type Classes
    - Type Aliases
    - algebraic data types
    - records and their accessor syntax
    - value assignments via `let`
    - FFI
    - pattern matching
    - pattern guards
- Elm is more approachable simply because it is less powerful and requires learning less. [Elm_PureScript_In_Depth_Overview]
- Elm could be a useful 'gateway drug' into PureScript [Elm_PureScript_In_Depth_Overview]
- PS has type classes whereas Elm does not: one reason why one might want to use PS instead of Elm. [Elm_PureScript_In_Depth_Overview]
- Elm is appealing because it's application structure is well-understood. To get the same appeal, the 'best practices' for application structure should be well documented in PS. [Elm_PureScript_In_Depth_Overview]
- Pux could be a "gateway drug" library from Elm into PS [Elm_PureScript_In_Depth_Overview]
- The `do` syntax was not immediately understood by the author. [Elm_PureScript_In_Depth_Overview]
- Not being able to mutate variables is a hard thing to initally grasp by new learners who are used to doing so freely. [Elm_PureScript_In_Depth_Overview]
- PS is more precise and powerful at a lower level than Elm. [Elm_PureScript_In_Depth_Overview]
- PureScript by Example uses `unsafePartial` in such a way that it might wrongly imply that one uses it more frequently than one actually does. [Elm_PureScript_In_Depth_Overview]
- The reasons for using `unsafePartial` might not be well-documented/explained [Elm_PureScript_In_Depth_Overview]
- Good summary of the differences between Elm and PS' handling of partial functions: "Elm strive to be total and prevent you from shooting yourself in the foot in any way, while Purescript gives you more freedom, but you have to understand the consequences of what youâ€™re doing." [Elm_PureScript_In_Depth_Overview]
- I don't know whether this concept (local and controlled side effects are still considered 'pure' if functions are referentially transparent) is well-documented in PureScript learning resources (even in my own, Jordan's PureScript Reference) [Elm_PureScript_In_Depth_Overview]
- The main goal is not "Should I learn Purescript?" But "I want to learn an FP language. Between Haskell and Purescript, which one is easier to learn since both use the same concepts that translate easily between both languages (e.g. type classes, Functor, etc.)?" [Learn_PureScript_or_Haskell_First]
- A number of usability issues (REPL slows to a crawl with 10+ packages; bower as package management with psc-package still a WIP) stopped one commentator from continuing choosing PS over Haskell as a language to learn FP. [Learn_PureScript_or_Haskell_First]
    - Sddressing this comment, some have been resolved whereas some others have not. AFAIK, the REPL no longer responds that slowly. `psc-package` is that stack-like alternative mentioned above that is become more established. Moreover, `spago` addresses some of its shortcomings due to the tedious nature of modifying packaget sets. However, `spago` does not yet have as much support in various things as `psc-package`.
- If one's goal is to learn an FP language, learning Haskell and then PureScript isn't necessarily a bad idea since Haskell and PureScript are very similar and Haskell is arguably more powerful than PureScript. However, if one's goal is to learn PureScript or do website development, it would be unfortunate to learn Haskell before learning PureScript. [Learn_PureScript_or_Haskell_First]
- GHC has better error messages than PureScript. This was likely true. I'm not whether that gap has decreased in the last year or not and by how much. I think it's likely still the same. [Learn_PureScript_or_Haskell_First]
- a core contributor for PS did not recommend PS to people new to FP seemingly because the learning resources for PS were not as good as Haskell's. [Learn_PureScript_or_Haskell_First]
- The Haskell book has exercises in addition to its explanations. [Learn_PureScript_or_Haskell_First]
- Haskell has more documentation (but better?) than PureScript, so Haskell is recommended for newcomers. It's not entirely clear whether the Haskell documentation is "better" than PureScript, but it is implied. [Learn_PureScript_or_Haskell_First]
- Seems like Haskell had more material than PureScript: if one did not satisfy you or help you, you could look at another tutorial/guide. If you encounter the same situation in PureScript, tough luck as there isn't another tutorial/guide. [Learn_PureScript_or_Haskell_First]
- Haskell's stronger ecosystem might make it easier for the OP to learn domain-specific concepts (e.g. parsing, cryptography, etc.) in an FP style [Learn_PureScript_or_Haskell_First]
- It seems if one wants to do web development using an FP paradigm, Elm has better learning resources to help one get familiar with the concepts before switching to Purescript. Again, Elm as a "gateway drug" into PureScript seems like a good possibility. [Learn_PureScript_or_Haskell_First]
- Elm seems to provide a gentler introduction to FP concepts than Haskell or PureScript primarily because it has less features and potentially has better documentation than PureScript did at that time. [Learn_PureScript_or_Haskell_First]
- If one wants to do FP web development and get the full power of FP languages and is willing to pay the cost of a steeper learning curve, then they should start with PureScript. Still, this learning curve could be made less steep if there was more beginner-friendly documentation. [Learn_PureScript_or_Haskell_First]
- PS' type system is more granular, powerful, and polished than Haskell, avoiding some of its baggage. [Learn_PureScript_or_Haskell_First]
- While this person argues that it's generally easier to install and maintain PS than Haskell on a machine, that comment did not account for the major breaking changes that occurred in the `0.12.0` release. Other comments in this post also argue against this point. [Learn_PureScript_or_Haskell_First]
- "PureScript focuses on Web, Haskell is more general, but in case you're only interested in playing with a functional language, I'd pick PureScript for that." [Learn_PureScript_or_Haskell_First]
- Good insight here: one can look at material from all three languages (PS, Haskell, Elm) to get a better understanding for how the code works. In other words, the concepts can translate from one language to another. [Learn_PureScript_or_Haskell_First]
- In short, in this person's experience, PureScript is easy to set up and start coding unlike Haskell in various ways [Learn_PureScript_or_Haskell_First]
- Using PureScript was more fun than the hassle when compared to the commentator's experience with Haskell. [Learn_PureScript_or_Haskell_First]
- PureScript doesn't require adding language extensions like "OverloadedStrings" or running it with `-Wall` [Learn_PureScript_or_Haskell_First]
- To one person, Haskell's community seems less frinedly / welcoming than other languages' communities in general and the Purescript community specifically. [Learn_PureScript_or_Haskell_First]
- This factual statement just explains that one will be more productive overall in langauges that have more mature ecosystem and active communities. However, if one wants to specifically do web programming and not use Haskell's solutions to that problem and needs something more powerful than Elm, then one seems limited to Purescript, Elixir, or Closure. [Learn_PureScript_or_Haskell_First]
- Person thinks that one should only learn PS for web/JS replacement. [Learn_PureScript_or_Haskell_First]
- Person might not have known about PS' other backends that make it more viable in the long-term. [Learn_PureScript_or_Haskell_First]
- Learning one language or another does not matter since the type classes and general foundations apply equally to all of them. [Learn_PureScript_or_Haskell_First]
- PS' long-term value is that the language can compile to multiple backends quite easily. Still, the exact performance considerations are not as clear as one library maintainer realized when writing [Learn_PureScript_or_Haskell_First] `purescript-sequence`, a FingerTree implementation that was slower than Array until its size got very large.
- Good summary of the learning curves of these languages: Elm is lowest, PS is next, Haskell is highest. [Learn_PureScript_or_Haskell_First]
- The target / purpose for learning FP langauge should be the controlling factor. [Learn_PureScript_or_Haskell_First]
- PureScript has better integration with JS build tools (e.g. webpack, parcel, etc.) than Haskell [Learn_PureScript_or_Haskell_First]
